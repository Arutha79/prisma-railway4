import { Injectable } from '@nestjs/common';
import * as fs from 'fs/promises';
import * as path from 'path';

interface Souvenir {
  date: string;
  type: string;
  titre: string;
  contenu: string;
}

interface Memoire {
  meta: any;
  historique: Souvenir[];
}

function nettoyerR√©ponseAvantM√©moire(contenu: string): string {
  // Supprime tous les blocs de type üß† Souvenir du ... : "..."
  return contenu.replace(/üß† Souvenir du .*?: ".*?"/gs, '').trim();
}

function estSouvenirD√©j√†Pr√©sent(contenu: string, historique: Souvenir[]): boolean {
  return historique.some(s => s.contenu === contenu);
}

@Injectable()
export class MemoryService {
  private readonly filePath = path.join(__dirname, '../../prisma_memory.json');

  private async loadMemory(): Promise<Memoire> {
    const data = await fs.readFile(this.filePath, 'utf-8');
    return JSON.parse(data);
  }

  private async saveMemory(memoire: Memoire): Promise<void> {
    const json = JSON.stringify(memoire, null, 2);
    await fs.writeFile(this.filePath, json, 'utf-8');
  }

  async ajouterSouvenir(reponseBrute: string): Promise<void> {
    const contenuNettoye = nettoyerR√©ponseAvantM√©moire(reponseBrute);

    // Ignore les r√©ponses trop courtes ou vides
    if (!contenuNettoye || contenuNettoye.length < 10) return;

    const memoire = await this.loadMemory();

    if (estSouvenirD√©j√†Pr√©sent(contenuNettoye, memoire.historique)) return;

    const nouveauSouvenir: Souvenir = {
      date: new Date().toISOString(),
      type: 'souvenir',
      titre: 'R√©ponse Prisma',
      contenu: contenuNettoye,
    };

    memoire.historique.push(nouveauSouvenir);
    await this.saveMemory(memoire);
  }
}
