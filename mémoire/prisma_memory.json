import { Injectable } from '@nestjs/common';
import * as fs from 'fs/promises';
import * as path from 'path';

interface Souvenir {
  date: string;
  type: string;
  titre: string;
  contenu: string;
}

interface Memoire {
  meta?: any;
  historique: Souvenir[];
}

function nettoyerR√©ponseAvantM√©moire(contenu: string): string {
  return contenu.replace(/üß† Souvenir du .*?: ".*?"/gs, '').trim();
}

function estSouvenirD√©j√†Pr√©sent(contenu: string, historique: Souvenir[]): boolean {
  return historique.some(s => s.contenu === contenu);
}

@Injectable()
export class MemoryService {
  private readonly filePath = path.resolve(__dirname, '../../m√©moire/prisma_memory.json');

  private async loadMemory(): Promise<Memoire> {
    try {
      const data = await fs.readFile(this.filePath, 'utf-8');
      return JSON.parse(data);
    } catch (err) {
      console.warn('‚ö†Ô∏è Memoire introuvable ou illisible. Nouveau fichier initialis√©.');
      return { historique: [] };
    }
  }

  private async saveMemory(memoire: Memoire): Promise<void> {
    const json = JSON.stringify(memoire, null, 2);
    await fs.writeFile(this.filePath, json, 'utf-8');
  }

  async ajouterSouvenir(reponseBrute: string): Promise<void> {
    const contenuNettoye = nettoyerR√©ponseAvantM√©moire(reponseBrute);

    if (!contenuNettoye || contenuNettoye.length < 10) return;

    const memoire = await this.loadMemory();

    if (estSouvenirD√©j√†Pr√©sent(contenuNettoye, memoire.historique)) return;

    const nouveauSouvenir: Souvenir = {
      date: new Date().toISOString(),
      type: 'souvenir',
      titre: 'R√©ponse Prisma',
      contenu: contenuNettoye,
    };

    memoire.historique.push(nouveauSouvenir);
    await this.saveMemory(memoire);
  }
}
